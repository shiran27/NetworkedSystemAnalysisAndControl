% Generate the system
clear all
close all 
clc

%% Create a network object
network = Network(0);

% Number of subsystems
numOfSubsystems = 3; 
dimentionOfSpace = 2;
sizeOfSpace = 1;
communicationRadius = 0.9;

% subsystem dims
for i = 1:1:numOfSubsystems
    dims{i}.n = 2; % x
    dims{i}.p = 1; % u
    dims{i}.q = 1; % w  
    dims{i}.m = 1; % y
end

rng(5) % 5 seems to be the ideal case

% Create the network and plot it
network = network.loadARandomNetwork(numOfSubsystems,dimentionOfSpace,sizeOfSpace,communicationRadius,dims);
% network = network.loadTheCustomNetwork();
network.shiftLocations(-0.05,-0.2);
network.drawNetwork(1,[false,0,1,0.2,0.8]);


% Creating the state space representation of the system and actual stability and passivity
[A,B,C,D,E,F,x] = network.getNetworkMatrices()
networkedSystem = ss(A,E,C,F);
isStable1 = isstable(networkedSystem)
isPassive1 = isPassive(networkedSystem)


%% Check stability in a distributed manner, and derive stabilizing controller
isStable2 = network.checkStability([],2)
[K1, isStabilizable21] = network.designLocalStabilizingSFBControllers([])
isStabilizable22 = ~any(real(eig(A+B*K1))>0)

%% Check passivity in a distributed manner and derive a passivating controller
[Q,S,R] = network.getSomeQSRMatrices('passive') % strictly passive, random, passive
network.storeQSRMatrices(Q,S,R); % store information locally at each sub-system
isPassive2 = network.checkQSRDissipativity([])

[K21, isPassive3] = network.designGlobalDissipatingSFBControllers()
% [K22, isDissipative2] = network.designLocalDissipatingSFBControllers([]);
networkedSystem2 = ss(A+B*K21,E,C,F);
isPassive4 =  isPassive(networkedSystem2)


%% 
rng(i)





%% Find the optimal indexing scheme
[bestIndexing, minCost, worstIndexing, maxCost, basicIndexingCost] = network.findOptimumIndexing()
% network.drawIndexing(bestIndexing)
% network.drawIndexing(worstIndexing)



% Simulate the uncontrolled system (with some qsr passivity level)



% Simulate the stabilized system


% Simulate the passivated system

